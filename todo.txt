TODO(chad): 
  -- FEATURES
    - weirdness when a line is exactly virtual_line_length characters long and then followed by a newline and some more characters
    - up/down (and cmd + up/down) with multiple cursors
    - backend-supported 'move-by'
      - move to beginning/end of line
      - move to next/previous word
        - probably make it configurable as to what counts as a 'word'
      - move to next/previous blank line
    - find/replace
      - will need to be able to efficiently iterate through leaf nodes in order.
      - going from the top down to get char 1, char 2, char 3, etc. will not be very efficient.
    - keybindings, modal editing
    - cursor history (cirucular buffer that we can navigate which carries a history of cursor_info, similar to IntelliJ)
      - should this work across multiple files? what if we make significant edits, the cursor positions will be wrong
      - should make sure the cursor is always visible when seeking to a position in the history
    - watch open files for changes (?)
      - indicate when a file has changed on disk since we started editing it
      - maybe just provide a 'reload from disk' command
    - tokenization (possibly supporting custom api?) and corresponding highlighting of grammars
      - test on json
    - selection through click/drag
    - plugins, user-created commands
    - support other file encodings
      - UTF-16
        - Use BOM if applicable to determine file encoding (and, of course, byte order)
      - binary?

  -- CORRECTNESS
    - handle combining glyphs

  -- PERFORMANCE
    - delete can be made faster if we know we're not deleting a newline
    - how to efficiently make sure that the cursor is always visible?
